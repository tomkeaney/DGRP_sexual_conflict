---
title: "Sexually antagonistic selection in the DGRP"
author: "Thomas Keaney and Luke Holman"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = FALSE)
```

## Load packages and the data

First load the packages

```{r load packages}

library(tidyverse) # for tidy coding
library(RColorBrewer) # for custom colours
library(rcartocolor) # cool colours
library(kableExtra) # for scrolling tables
library(patchwork) # for cool plots
library(brms) # for bayesian models
library(tidybayes) # for more bayesian things
library(DT) # for interactive tables
library(broom) # convert results of functions into tables
library(ggtext) # for markdown features in ggplot
library(MetBrewer)

DGRP_data <- left_join(
  read_csv("data/all.dgrp.phenos_unscaled.csv") %>% 
    mutate(line = as.factor(line)),
  read_csv("data/meta_data_for_all_traits.csv") %>% 
    group_by(Reference) %>% 
    mutate(study_ID = as.factor(cur_group_id()))
)
```

## Selecting data appropriate for analysis

We use a pruned dataset from the _DGRP database_ (Belonte, Keaney, _et al_. 2023). We select traits that have been measured in 80 or more lines and do not include the three mass datasets on the microbiome and metabolome (Everett _et al_. 2020, Jin _et al_. 2020 and Zhou _et al_. 2020). 

```{r}
# Remove traits that are difficult to interpret or that have transformed means

selected.dgrp.phenos_unscaled <-
  DGRP_data %>% 
  filter(Reference != "Jin et al (2020) PLOS Genetics" & # Normalised
           Reference != "Zhou et al (2020) Genome Research" & # Normalised
           Reference != "Everett et al (2020) Genome Research" & # values reported on log scale
           `# lines measured` >= 80) # Filter by number of lines measured

# how many traits do we have?
num_unique_traits <- length(unique(selected.dgrp.phenos_unscaled$Trait))
# how many studies are they measured across?
num_unique_studies <- length(unique(selected.dgrp.phenos_unscaled$Reference))
```

After this selection process, `r num_unique_traits - 2` remain, that were measured across `r num_unique_studies - 1` studies.

Next, we wrangle the data so that for each trait we have line mean values for females and males, as well as fitness values for that line in females and males. We also include some helpful metadata for downstream analysis. 

```{r}

# Create a tibble that only contains data from traits that have been measured in both sexes

# remove the fitness measures from the trait column and add a column called 'pooled' that specifies if the data was measured in both sexes at once

trait_data <-
  selected.dgrp.phenos_unscaled %>%  filter(!str_detect(Trait, "fitness")) %>% 
  mutate(Pooled = case_when(Sex == "Pooled" ~ "Yes",
                           Sex != "Pooled" ~ "No"))

trait_data_female <-
  trait_data %>% filter(!str_ends(Trait, ".m")) %>% 
  mutate(Trait = case_when(Sex == "Female" ~ gsub('.{2}$', '', Trait), # remove the sex indicating suffix's
                           Sex == "Pooled" ~ Trait)) %>% 
  rename(female_trait_value = trait_value) %>% 
  select(-Sex)

trait_data_male <-
  trait_data %>% filter(!str_ends(Trait, ".f")) %>% 
  mutate(Trait = case_when(Sex == "Male" ~ gsub('.{2}$', '', Trait), # remove the sex indicating suffix's
                           Sex == "Pooled" ~ Trait)) %>% 
  rename(male_trait_value = trait_value) %>% 
  select(-Sex)

trait_fitness_data <- 
  full_join(trait_data_male, trait_data_female, 
            by = c("Trait", "line", "Life_stage", "Trait guild", "study_ID", "Pooled"),
            suffix = c(".male", ".female")) %>% 
  select(line, Trait, Life_stage, `Trait guild`, female_trait_value, male_trait_value, `# lines measured.female`, `# lines measured.male`, study_ID, Pooled)

# create a dataset with a new column - female_fitness 

fitness_data_1 <-
  selected.dgrp.phenos_unscaled %>%
  filter(Trait == "fitness.early.life.f") %>% 
  rename(female_fitness = trait_value) %>% 
  select(line, female_fitness)

# do the same for male_fitness

fitness_data_2 <-
  selected.dgrp.phenos_unscaled %>%  
  filter(Trait == "fitness.early.life.m") %>% 
  rename(male_fitness = trait_value) %>% 
  select(line, male_fitness)

# join

fitness_data_join1 <-
  left_join(trait_fitness_data, fitness_data_1)

# second join, this time with trait and meta data

trait_fitness_full_data <-
  left_join(fitness_data_join1, fitness_data_2) #%>% 
  #group_by(Trait) %>% # group the data by trait so that scaling works on a per trait basis
  #mutate(trait_value = as.numeric(scale(trait_value))) # scale the data for each trait

```

$~$

## Calculating *R*: the response to selection

$~$

If we follow the accepted assumption that line means represent the breeding value for a trait for that given line, the variance across lines equals the genetic variance in the DGRP population for that trait.

We can then estimate the response to selection ($R$) for a trait using **Robertson's secondary theorem of natural selection** (also known as the **Robertson covariance**), which states that $R$ is equivalent to the covariance between a traits breeding values ($A_z$) and the breeding values for relative fitness ($A_w$):

$$R = \sigma(A_z, A_w)$$

$~$

### Build models to calculate $R$

Build functions to run the models

```{r}

#female_selection_model <-
 # brm(data = trait_fitness_full_data %>% filter(Trait == "flight.performance"),
  #    family = gaussian,
   #   bf(mvbind(female_fitness, female_trait_value) ~ 0, sigma ~ 0) + set_rescor(TRUE),
    #  prior(lkj(2), class = rescor),
     # chains = 4, cores = 4, 
      #seed = 1)   

female_selection_model <-
  brm(data = trait_fitness_full_data %>% filter(Trait == "flight.performance"),
      family = gaussian,
      bf(mvbind(female_fitness, female_trait_value) ~ 1) + set_rescor(TRUE),
      prior(lkj(2), class = rescor),
      chains = 4, cores = 4, iter = 6000, warmup = 2000,
      seed = 1, file = "fits/test_model_female")   

# sample from the posterior - this will create a tibble with two columns - Trait and rfm

posterior <- as_draws_df(female_selection_model) %>% 
  rename(Response_to_selection_female = rescor__femalefitness__femaletraitvalue) %>% 
  mutate(BG_female = Response_to_selection_female / sigma_femaletraitvalue^2, 
         Trait = "flight.performance") %>% 
  select(Trait, Response_to_selection_female, sigma_femaletraitvalue, BG_female) %>% 
  as_tibble()

# make a function to update the model and the posterior sample output with your desired trait

R_female_calculator <- function(selected_trait){
  
  data <- trait_fitness_full_data %>% filter(Trait == selected_trait)
  
  model <- update(
    female_selection_model, newdata = data,
      chains = 4, cores = 4, iter = 6000, warmup = 2000,
      seed = 1)
  
  posterior <- 
    as_draws_df(model) %>% 
    rename(Response_to_selection_female = rescor__femalefitness__femaletraitvalue) %>% 
    mutate(Trait = selected_trait,
           V_G_trait = sigma_femaletraitvalue^2,
           S_female = Response_to_selection_female / V_G_trait) %>% 
    select(Trait, Response_to_selection_female, V_G_trait, S_female) %>% 
    as_tibble()
  
  posterior
}

# Find the traits that have been measured in females (this includes pooled traits currently)

Female_measurements <- trait_fitness_full_data %>% filter(female_trait_value != "NA")

trait_list_female <- unique(Female_measurements$Trait)


# male estimates

male_selection_model <-
  brm(data = trait_fitness_full_data %>% filter(Trait == "posterior.lobe.size"),
      family = gaussian,
      bf(mvbind(male_fitness, male_trait_value) ~ 1) + set_rescor(TRUE),
      prior(lkj(2), class = rescor),
      chains = 4, cores = 4, iter = 6000, warmup = 2000,
      seed = 1, file = "fits/test_model_male")   

# sample from the posterior - this will create a tibble with two columns - Trait and rfm

post <- as_draws_df(male_selection_model) %>% 
  rename(Response_to_selection_male = rescor__malefitness__maletraitvalue) %>% 
  mutate(V_G_trait = sigma_maletraitvalue^2,
         BG_male = Response_to_selection_male / V_G_trait, 
         Trait = "posterior.lobe.size") %>% 
  select(Trait, Response_to_selection_male, V_G_trait, BG_male) %>% 
  as_tibble()

# make a function to update the model and the posterior sample output with your desired trait

R_male_calculator <- function(selected_trait){
  
  data <- trait_fitness_full_data %>% filter(Trait == selected_trait)
  
  model <- update(
    male_selection_model, newdata = data,
    chains = 4, cores = 4, iter = 6000, warmup = 2000,
    seed = 1)
  
  posterior <- 
    as_draws_df(model) %>% 
    rename(Response_to_selection_male = rescor__malefitness__maletraitvalue) %>% 
    mutate(Trait = selected_trait,
           V_G_trait = sigma_maletraitvalue^2,
           S_male = Response_to_selection_male / V_G_trait) %>% 
    select(Trait, Response_to_selection_male, V_G_trait, S_male) %>% 
    as_tibble()
  
  posterior
}

male_measurements <- trait_fitness_full_data %>% filter(male_trait_value != "NA")

trait_list_male <- unique(male_measurements$Trait)

```

Run the models using `R_female_calculator` and `R_male_calculator`

```{r}
# run the female function

Run_function <- FALSE # Change this to TRUE to run the models

if(Run_function){
  R_female <- map_dfr(trait_list_female, R_female_calculator) # map_dfr returns a data frame created by row-binding each output
  write_csv(R_female, file = "data/R_female.csv")
} else R_female <- read_csv("data/R_female.csv")

# run the male function

if(Run_function){
  R_male <- map_dfr(trait_list_male, R_male_calculator) # map_dfr returns a data frame created by row-binding each output
  write_csv(R_male, file = "data/R_male.csv")
} else R_male <- read_csv("data/R_male.csv")
```

$~$

Combine the two data frames and estimate the net response to selection as 

$$R_{net} = \frac{R_F + R_M}{2}$$

In the same code chunk, we also calculate the difference between the sexes for the response to selection in each trait as

$$R_F - R_M$$

to test for the weak form of intralocus sexual conflict, as per Bonduriansky and Chenoweth (2009). Note that this measure does not reveal whether a trait is truly sexually antagonistic, as a difference is possible when a selection response is sexually concordant but with sex differences in strength. A difference can also result from the absence of a response in one sex and a strong response in the other. 

```{r}
Common_traits <- 
  inner_join(
    R_female %>% distinct(Trait),
    R_male %>% distinct(Trait))


R_both_sexes <-
  bind_cols(
    
    left_join(
      Common_traits,
      R_female %>% 
        select(Trait, Response_to_selection_female)) %>% 
      rename(Trait_female = Trait),
    
    left_join(
      Common_traits,
      R_male %>% 
        select(Trait, Response_to_selection_male)) %>% 
      rename(Trait_male = Trait)
  ) %>% 
  # the next line ground truths that bind_cols is binding the right columns
  # if bind_cols has worked the next line will not affect the tibble
  filter(Trait_female == Trait_male) %>% 
  select(-Trait_male) %>% 
  rename(Trait = Trait_female) %>% 
  # now the important things
  mutate(Net_response = (Response_to_selection_female + Response_to_selection_male) /2,
         Diff_in_response = Response_to_selection_female - Response_to_selection_male)

```

$~$

## Visualise the responses to selection for each trait

$~$

```{r, fig.height=40}
p1 <-
  R_female %>% 
  group_by(Trait) %>% 
  mutate(avg_R = median(Response_to_selection_female)) %>%
  ggplot(aes(Response_to_selection_female, fct_reorder(Trait, avg_R))) +
  stat_interval(.width = c(0.05, 0.66, 0.95), 
                height = 1, show.legend = F) +
  rcartocolor::scale_color_carto_d(palette = "Purp") +
  coord_cartesian(xlim = c(-0.5, 0.5)) +
  geom_vline(linetype = 2, xintercept = 0, linewidth = 1) +
  labs(x = "Response to selection in females",
       y = "Trait") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank(),
        text = element_text(size=14),
        axis.text.y = element_text(size = 8)) 

p1
```

**Figure S1**. The response to selection in females for all traits in our dataset.

$~$

```{r, fig.height=40}
p2 <-
  R_male %>% 
  group_by(Trait) %>% 
  mutate(avg_R = median(Response_to_selection_male)) %>%
  ggplot(aes(Response_to_selection_male, fct_reorder(Trait, avg_R))) +
  stat_interval(.width = c(0.05, 0.66, 0.95), 
                height = 1, show.legend = F) +
  rcartocolor::scale_color_carto_d(palette = "Peach") +
  coord_cartesian(xlim = c(-0.5, 0.5)) +
  geom_vline(linetype = 2, xintercept = 0, linewidth = 1) +
  labs(x = "Response to selection in males",
       y = "Trait") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank(),
        text = element_text(size=14),
        axis.text.y = element_text(size = 8)) 

p2

```

**Figure S2**. The response to selection in males for all traits in our dataset.

$~$

Choose the top 20 traits for each sex in terms of absolute $R$ and present them in a Table

**Table 1**. The top 20 traits with the strongest responses to selection in the DGRP. The sign of $R$ indicates the direction of the response.

```{r}
R_summary <-
  bind_cols(
    R_female %>%
      select(Trait, Response_to_selection_female) %>% 
      group_by(Trait) %>% 
      summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975)), .cores = 4) %>%
      ungroup() %>% 
      select(-variable) %>% 
      rename(`R` = median, `Estimated error` = sd,
             `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`, `Trait in females` = Trait)  %>% 
      mutate(R_abs = abs(`R`)) %>% 
      arrange(-R_abs) %>% 
      slice_head(n = 20) %>% 
      select(-R_abs) %>% 
      mutate(across(`R`:`97.5% CI`, ~ round(.x, digits = 3)),
             Notable = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                 `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                 TRUE ~ " ")),
    
    # note that I use the hack to give the CI columns very similar names. I put a space i.e. " " within the male CI names to make the names appear the same without calling an indexing error 
    
    R_male %>%
      select(Trait, Response_to_selection_male) %>% 
      group_by(Trait) %>% 
      summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975)), .cores = 4) %>%
      ungroup() %>% 
      select(-variable) %>% 
      rename(`R ` = median, `Estimated error ` = sd,
             `2.5% CI ` = `2.5%`, `97.5% CI ` = `97.5%`, `Trait in males` = Trait) %>% 
      mutate(R_abs = abs(`R `)) %>% 
      arrange(-R_abs) %>% 
      slice_head(n = 20) %>% 
      select(-R_abs) %>% 
      mutate(across(`R `:`97.5% CI `, ~ round(.x, digits = 3)),
             `Notable ` = case_when(`2.5% CI ` < 0 & `97.5% CI ` < 0 ~ "*",
                                    `2.5% CI ` > 0 & `97.5% CI ` > 0 ~ "*",
                                    TRUE ~ " "))
  )

kbl(R_summary) %>%
  kable_minimal(font_size = 12) %>% 
  column_spec(1, width = "22em") %>% 
  column_spec(7, width = "24em")  

```

$~$

**Table 2**. The top 20 traits with the strongest net responses to selection in the DGRP. We use the mean of $R_F$ and $R_M$ as the net response to selection. The sign of $R$ indicates the direction of the response. 

```{r}
R_both_sexes %>% 
  select(Trait, Net_response) %>% 
  group_by(Trait) %>% 
  summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975)), .cores = 4) %>%
  ungroup() %>% 
  select(-variable) %>% 
  rename(`Net R` = median, `Estimated error ` = sd, `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`) %>% 
  mutate(R_abs = abs(`Net R`)) %>% 
  arrange(-R_abs) %>% 
  slice_head(n = 20) %>% 
  select(-R_abs) %>% 
  mutate(across(`Net R`:`97.5% CI`, ~ round(.x, digits = 3)),
         `Notable ` = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                TRUE ~ " ")) %>%
  
  kbl() %>%
  kable_minimal(full_width = F, font_size = 12) %>% 
  column_spec(1, width = "21em")
```

$~$

**Table 3**. The top 20 traits with the largest difference between the sexes in the response to selection in the DGRP. We use $R_F - R_M$ as the difference.

```{r}
R_both_sexes %>% 
  select(Trait, Diff_in_response) %>% 
  group_by(Trait) %>% 
  summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975)), .cores = 4) %>%
  ungroup() %>% 
  select(-variable) %>% 
  rename(`Female R - Male R` = median, `Estimated error ` = sd, `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`)  %>% 
  mutate(R_abs = abs(`Female R - Male R`)) %>% 
  arrange(-R_abs) %>% 
  slice_head(n = 20) %>% 
  select(-R_abs) %>% 
  mutate(across(`Female R - Male R`:`97.5% CI`, ~ round(.x, digits = 3)),
         `Notable ` = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                TRUE ~ " ")) %>% 
  
  kbl() %>%
  kable_minimal(full_width = F, font_size = 12) %>% 
    column_spec(1, width = "21em")
```

$~$

## Estimate across-trait grand means for $R$ in each sex

```{r}

R_meta <-
  bind_rows(
    left_join(
      
      R_female %>% 
        select(Trait, Response_to_selection_female) %>%
        group_by(Trait) %>% 
        summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975)), .cores = 4) %>%
        ungroup() %>% 
        select(Trait, median, sd) %>% 
        rename(Response_to_selection = median),
      
      trait_fitness_full_data %>% 
        distinct(Trait, .keep_all = TRUE) %>% 
        select(Trait, Life_stage, `Trait guild`, study_ID, Pooled)
    ) %>% 
      mutate(Sex = "Female"),
    
    left_join(
      
      R_male %>% 
        select(Trait, Response_to_selection_male) %>%
        group_by(Trait) %>% 
        summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975)), .cores = 4) %>%
        ungroup() %>% 
        select(Trait, median, sd) %>% 
        rename(Response_to_selection = median),
      
      trait_fitness_full_data %>% 
        distinct(Trait, .keep_all = TRUE) %>% 
        select(Trait, Life_stage, `Trait guild`, study_ID, Pooled)
    ) %>% 
      mutate(Sex = "Male")
  ) %>% 
  rename(Trait_guild = `Trait guild`) %>% 
  mutate(absolute_response = abs(Response_to_selection))


grand_R_model <- 
  brm(absolute_response | weights(1/sd) ~ 1 + Sex + (1|study_ID) + (1|Trait),
      family = brmsfamily(family = "Gamma"), # for all positive values after taking the absolute value
      data = R_meta,
      prior = c(#prior(exponential(1), class = Intercept),
        prior(exponential(1), class = sd),
        prior(exponential(1), class = shape),
        prior(normal(0, 0.25), class = b)),
      warmup = 4000, iter = 8000,
      seed = 1, cores = 4, chains = 4,
      control = list(adapt_delta = 0.99, max_treedepth = 15),
      file = "fits/grand_R_model")

print(grand_R_model)

```

Get model predictions and plot

```{r}
R_posterior <-
  grand_R_model %>% 
  as_draws_df() %>% 
  mutate(Males = inv_logit_scaled(b_Intercept + b_SexMale),
         Females = inv_logit_scaled(b_Intercept),
         sex_diff = Males - Females,
         percent_diff = sex_diff / Females * 100) %>% 
  select(Females, Males, sex_diff, percent_diff) %>% 
  pivot_longer(cols = everything(), names_to = "Parameter", values_to = "R_stat")

R_p1 <-
  R_posterior %>% 
  filter(Parameter == c("Females", "Males")) %>% 
  ggplot(aes(x = R_stat, y = Parameter)) +
  stat_halfeye(.width = c(0.66, 0.95), alpha = 0.9, 
               fill = carto_pal(7, "Peach")[4],
               point_interval = "median_qi", point_fill = "white",
               shape = 21, point_size = 4, stroke = 1.5,
               slab_colour = "black") + # width indicates the uncertainty intervals: here we have 66% and 95% intervals + # width indicates the uncertainty intervals: here we have 66% and 95% intervals+
  xlab(expression(italic(R)* ", the response to selection")) +
  ylab("Sex") +
  #coord_cartesian(ylim = c(1.5,2.1)) +
  #scale_x_continuous(breaks = c(0.6, 0.9, 1.2, 1.5, 1.8), limits = c(0.5, 2)) +
  theme_minimal() + 
  theme(panel.background = element_rect(fill='transparent'),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        plot.background = element_rect(fill='transparent', color=NA),
        legend.position = "none",
        text = element_text(size=14))

R_p2 <-
  R_posterior %>% 
  filter(Parameter == "percent_diff") %>% 
  ggplot(aes(x = R_stat, y = NULL)) +
  stat_halfeye(.width = c(0.66, 0.95), alpha = 0.9, 
               fill = carto_pal(7, "Peach")[4],
               point_interval = "median_qi", point_fill = "white",
               shape = 21, point_size = 4, stroke = 1.5,
               slab_colour = "black") + # width indicates the uncertainty intervals: here we have 66% and 95% intervals + # width indicates the uncertainty intervals: here we have 66% and 95% intervals+
  geom_vline(xintercept = 0, linetype = 2, linewidth = 1.2) +
  coord_cartesian(ylim = c(-0.1,1)) +
  xlab(expression("% increase in "*italic(R)* " from females to males")) +
  ylab(NULL) +
  theme_minimal() + 
  theme(panel.background = element_rect(fill='transparent'),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        plot.background = element_rect(fill='transparent', color=NA),
        axis.text.y = element_blank(),
        legend.position = "none",
        text = element_text(size=14))

R_p1 / R_p2 +
  plot_annotation(tag_levels = 'a')
  
```

**Figure XX**. **a** $\overline{R}$, the estimated mean response to selection (absolute value) across all traits measured in the DGRP, for females and males. For each trait $R = \sigma(A_z, A_w)$, where $A_z$ is the trait breeding value and $A_w$ is the breeding value for fitness. **b** traits have a stronger mean response to selection in males compared to females.

$~$

## Identifying traits under sexually antagonistic selection

$~$

We have found $R$ for traits in females and males. For those traits where we have a measure of both, we can estimate the concordance of the response to selection between the sexes using the I metric presented in [Innocenti and Morrow (2011)]( https://doi.org/10.1111/j.1558-5646.2010.01021.x).

$$I = \frac{\beta'_M \beta'_F}{\sqrt{\frac{(\beta'_M)^2 + (\beta'_F)^2}{2}}}$$

Where $\beta'_F$ and $\beta'_M$ = are phenotypic selection gradients. We substitute $R_F$ and $R_M$ for $\beta'_F$ and $\beta'_M$. This makes our test for sexually antagonistic traits more conservative, as non-zero $R$ requires both directional selection on the trait and the presence of additive genetic variance for the trait. 

This index is positive when selection is concordant in the two sexes, negative when antagonistic in the two sexes, and is zero when selection is absent in one sex (note that it will miss conflict that occurs when strong stabilizing selection is present in that sex). Finally it is proportional to the absolute intensity of selection (track the diagonals in the visualisation below to get a sense of this). Note that because we use $R$ instead of $\beta'$, $I$ is bounded between -1 to 1 in our analysis.  

Additionally, it is symmetrical and normally distributed for a random set of normally distributed $\beta'_M$, $\beta'_F$. $|I|$ is also always included in the interval between the absolute values of the selection gradient in the two sexes, and it coincides with them when $\beta'_M = \beta'_F$. As a potential drawback, it should be noted that such quantity is not defined when $\beta'_M = \beta'_F = 0$.
 
First let's test that we've coded $I$ correctly. We simulate combinations of $R_F$ and $R_M$ and calculate $I$.
 
```{r}
# Let's test that the I index behaves as it should

sim_I <-
  expand_grid(R_F = seq(from = -1, to = 1, by = 0.01),
         R_M = seq(from = -1, to = 1, by = 0.01)) %>% 
  mutate(I = R_F * R_M / sqrt(((R_F)^2 + (R_M)^2)/2))

sim_I %>% 
  ggplot(aes(x = R_F, y = R_M, fill = I)) +
  geom_raster() +
  stat_contour(aes(z = I), colour = "black", binwidth = 0.1) +
  stat_contour(aes(z = I), colour = "black", breaks = 8, linetype = 2) +
  scale_fill_gradientn(colours = met.brewer(name = "Paquin", 7)) + #OKeeffe1 or paquin also good
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) +
  labs(x = "Response to selection in females", y = "Response to selection in males") +
  theme_tidybayes() +
  theme(text = element_text(size = 14))
```
 
Calculate $I$ for each draw of each trait
 
```{r}

I_index <-
  R_both_sexes %>% 
  mutate(I = Response_to_selection_female * Response_to_selection_male / sqrt(((Response_to_selection_female)^2 + (Response_to_selection_male)^2)/2))

# make the table

bind_rows(
  I_index %>% 
    select(Trait, I) %>% 
    group_by(Trait) %>% 
    summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975)), .cores = 4) %>%
    ungroup() %>% 
    select(-variable) %>% 
    rename(I = median, `Estimated error ` = sd, `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`)  %>% 
    mutate(I_abs = abs(I)) %>% 
    arrange(-I) %>% 
    slice_head(n = 20) %>% 
    select(-I_abs) %>% 
    mutate(across(I:`97.5% CI`, ~ round(.x, digits = 3)),
           `Notable ` = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                  `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                  TRUE ~ " ")), 
  
  I_index %>% 
    select(Trait, I) %>% 
    group_by(Trait) %>% 
    summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975)), .cores = 4) %>%
    ungroup() %>% 
    select(-variable) %>% 
    rename(I = median, `Estimated error ` = sd, `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`)  %>% 
    mutate(I_abs = abs(I)) %>% 
    arrange(I) %>% 
    slice_head(n = 20) %>% 
    select(-I_abs) %>% 
    mutate(across(I:`97.5% CI`, ~ round(.x, digits = 3)),
           `Notable ` = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                  `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                  TRUE ~ " "))
) %>% 
    
    
  kbl() %>%
  kable_minimal(full_width = F, font_size = 12) %>% 
  column_spec(1, width = "25em") %>% 
  pack_rows("Sexually concordant R", 1, 20) %>% 
  pack_rows("Sexually antagonistic R", 21, 40)

```

Fit the $\overline{I}$ model

```{r}

I_data <-
  left_join(
    I_index %>% 
       select(Trait, I) %>% 
    group_by(Trait) %>% 
    summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975)), .cores = 4) %>%
    ungroup() %>% 
    select(-variable),
    
    trait_fitness_full_data %>% distinct(Trait, Life_stage, study_ID, `Trait guild`)
  ) %>% 
  rename(I = median, Trait_guild = `Trait guild`)

# fit the model

I_model <- 
  brm(data = I_data, 
      I | weights(sd) ~ 1 + (1|study_ID),
      family = gaussian,
      prior = c(prior(normal(0, 0.25), class = Intercept),
                prior(exponential(1), class = sd),
                prior(exponential(5), class = sigma)), 
      warmup = 4000, iter = 8000,
      seed = 1, cores = 4, chains = 4,
      control = list(adapt_delta = 0.9, max_treedepth = 10),
      file = "fits/I_model")

print(I_model)

```

Get model predictions and plot

```{r}
I_posterior <- 
    as_draws_df(I_model) %>% 
      select(b_Intercept, sigma)

I_posterior_long <-
bind_cols(
I_posterior,
    tibble(predictive_I = rnorm(16000, mean = I_posterior$b_Intercept, sd = I_posterior$sigma))
  ) %>% 
  select(-sigma) %>% 
  pivot_longer(cols = everything(), names_to = "parameter", values_to = "I")

```

Plot

```{r}
I_grand_mean <-
  I_posterior_long %>% 
  filter(parameter == "b_Intercept") %>% 
  ggplot(aes(x = I, y = NULL)) +
  stat_halfeye(aes(fill = after_stat(x > 0)),
               .width = c(0.66, 0.95), alpha = 0.9, 
               #fill = carto_pal(7, "Peach")[3],
               point_interval = "median_qi", point_fill = "white",
               shape = 21, point_size = 4, stroke = 1.5,
               slab_colour = "black") + # width indicates the uncertainty intervals: here we have 66% and 95% intervals + # width indicates the uncertainty intervals: here we have 66% and 95% intervals+
  scale_fill_manual(values = c(met.brewer(name = "Tam", n = 8)[4], met.brewer(name = "Tsimshian", n = 7)[3])) +
  ylab(NULL) +
  xlab(expression(italic(I)* " index grand mean")) +
  coord_cartesian(ylim = c(-0.1,1)) +
  #scale_x_continuous(breaks = c(0.6, 0.9, 1.2, 1.5, 1.8), limits = c(0.5, 2)) +
  theme_minimal() + 
  theme(panel.background = element_rect(fill='transparent'),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        plot.background = element_rect(fill='transparent', color=NA),
        legend.position = "none",
        axis.text.y = element_blank(),
        text = element_text(size=14))

I_predictive_dist <-
  I_posterior_long %>% 
  filter(parameter == "predictive_I") %>% 
  ggplot(aes(x = I, y = NULL)) +
  stat_halfeye(aes(fill = after_stat(x > 0)),
               .width = c(0.66, 0.95), alpha = 0.9, 
               #fill = carto_pal(7, "Peach")[3],
               point_interval = "median_qi", point_fill = "white",
               shape = 21, point_size = 4, stroke = 1.5,
               slab_colour = "black") + # width indicates the uncertainty intervals: here we have 66% and 95% intervals + # width indicates the uncertainty intervals: here we have 66% and 95% intervals+
  scale_fill_manual(values = c(met.brewer(name = "Tam", n = 8)[4], met.brewer(name = "Tsimshian", n = 7)[3])) +
  ylab(NULL) +
  xlab(expression(italic(I)* " posterior predictive distribution")) +
  coord_cartesian(ylim = c(-0.1,1)) +
  #scale_x_continuous(breaks = c(0.6, 0.9, 1.2, 1.5, 1.8), limits = c(0.5, 2)) +
  theme_minimal() + 
  theme(panel.background = element_rect(fill='transparent'),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        plot.background = element_rect(fill='transparent', color=NA),
        legend.position = "none",
        axis.text.y = element_blank(),
        text = element_text(size=14))

I_grand_mean / I_predictive_dist +
  plot_annotation(tag_levels = 'a')
```

**Figure XX**. **a** $\overline{I}$, the estimated mean $I$ index across all traits measured in both sexes in the DGRP, with associated 66 and 95% credible intervals. $I$ is calculated using the response to selection rather than selection gradients in our analysis. **b** The entire posterior predictive distribution for $I$, with associated 66 and 95% prediction intervals. This distribution shows where any randomly selected trait phenotyped across the DGRP is predicted to fall, based upon all previously phenotyped traits (that meet our criteria). In both panels, red area indicates parameter space where traits have sexually antagonistic responses to selection, while green area indicates traits that have sexually concordant responses to selection.
