---
title: "The response to selection, sexual antagonism and sexual concordance in the DGRP"
author: "Thomas Keaney and Luke Holman"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, cache = FALSE)
```

# Load packages and the data

$~$

First load the packages and build helper functions

```{r load packages}

library(tidyverse) # for tidy coding
library(MetBrewer) # for many nice colour palettes
library(rcartocolor) # more cool colours
library(kableExtra) # for scrolling tables
library(DT) # for interactive tables
library(patchwork) # to join mulitple plots nicely
library(brms) # for bayesian models
library(tidybayes) # for more bayesian things
library(bayestestR) # for the pd metric 
library(broom) # convert results of functions into tables
library(ggtext) # for markdown features in ggplot
library(ggrepel) # for plot labels in ggplot
library(ggnewscale) # to reset scales in ggplot 

# Create a function to build HTML searchable tables

my_data_table <- function(df){
  datatable(
    df, rownames=FALSE,
    autoHideNavigation = TRUE,
    extensions = c("Scroller",  "Buttons"),
    options = list(
      autoWidth = TRUE,
      dom = 'Bfrtip',
      deferRender=TRUE,
      scrollX=TRUE, scrollY=1000,
      scrollCollapse=TRUE,
      buttons =
        list('pageLength', 'colvis', 'csv', list(
          extend = 'pdf',
          pageSize = 'A4',
          orientation = 'landscape',
          filename = 'Trait_data')),
      pageLength = 2115
    )
  )
}

```

$~$

# Selecting data appropriate for analysis

We conducted a near-exhaustive search of the literature until January 2022, to obtain line mean estimates and associated meta-data for quantitative traits that have been measured in the DGRP. We did not include data collected for traits that had been measured in heterozygous combinations of multiple DGRP lines. In total, we identified 125 studies that reported line means or raw data for 2115 phenotypic traits. To ready the data for analysis, we grouped trait values by trait and sex and standardised the data to have mean = 0 and sd = 1. Sex-specific standardised line means for each trait were then combined with their standardised fitness estimates, obtained from [Wong and Holman (2023)](). We also include some helpful metadata for downstream analysis. We then pruned the dataset to only include traits that have been measured in single-sex cohorts, in 80 or more lines. We also removed 'intermediate' traits between genotype and phenotype from three mass datasets on the microbiome and metabolome (Everett _et al_. 2020 and Jin _et al_. 2020). 

```{r}

# load in the data, note that traits have already been standardised

DGRP_data <- 
  left_join(
    read_csv("data/all.dgrp.phenos_scaled.csv") %>% 
      mutate(line = as.factor(line)),
    read_csv("data/meta_data_for_all_traits.csv") %>%
      group_by(Reference) %>% 
      mutate(study_ID = as.factor(cur_group_id()),
             Pooled = if_else(Sex == "Pooled", "Yes", "No"))) %>% 
  left_join(read_rds("data/trait_names.rds"))
  
  
# Apply the selection criteria with the filter() function, then add a column each for female and male fitness

trait_data <-
  DGRP_data %>%  filter(!str_detect(Trait, "fitness"),
                        `# lines measured` >= 80 &
                          Pooled != "Yes" & 
                          Reference != "Jin et al (2020) PLOS Genetics" & 
                          Reference != "Everett et al (2020) Genome Research" &
                          !str_detect(Trait, "dopamine.response.to.paraquat.2021.m")) %>% # data for this trait was entered into the database incorrectly, it was only measured in 10 lines so should not be included in our analysis 
  
  # join the early life fitness data from Wong and Holman
  
  left_join(
    DGRP_data %>%
      filter(str_detect(Trait, "fitness.early.life")) %>% 
      select(line, Trait, trait_value) %>% 
      pivot_wider(names_from = Trait, values_from = trait_value) %>% 
      rename(female_fitness = fitness.early.life.f, male_fitness = fitness.early.life.m))


clean_meta_data <-
  trait_data %>% 
  select(Trait_nice, Trait, Life_stage, `Trait guild`, study_ID, Trait_nice, Reference, `Trait description`) %>% 
  distinct(Trait, .keep_all = TRUE)

```

$~$

**Table S1**. Traits included for analysis

```{r}
# how many studies did we start with?

table_data <- left_join(
  DGRP_data %>%
    distinct(Trait, .keep_all = TRUE) %>% 
    mutate(Measured_in = case_when(Sex == "Female" ~ "Females",
                                   Sex == "Male" ~ "Males",
                                   Sex == "Pooled" ~ "Mixed sex cohorts")) %>% 
    select(Trait_nice, Trait, Reference, `# lines measured`, Measured_in, `Trait description`),
  
  trait_data %>%
    distinct(Trait) %>% 
    mutate(Included = "Yes")
) %>%
  mutate(Included = if_else(is.na(Included), "No", Included)) %>% 
  select(-Trait) %>% 
  rename(Trait = Trait_nice, `Measured in` = Measured_in) %>% 
  arrange(desc(Included))

# Create a function to build HTML searchable tables

my_data_table(table_data %>% 
               select(Trait, Reference, `# lines measured`, `Measured in`, Included, `Trait description`))
```

$~$

Find the number of traits and studies included in our analysis.

```{r}

# how many studies and traits do we have after filtering?

num_unique_traits <- table_data %>% filter(Included == "Yes") %>% nrow()
# in females
num_unique_traits_f <- table_data %>% filter(Included == "Yes" & `Measured in` == "Females") %>% nrow()
# in males
num_unique_traits_m <- table_data %>% filter(Included == "Yes" & `Measured in` == "Males") %>% nrow()
# how many studies are they measured across in total?
num_unique_studies <- table_data %>% filter(Included == "Yes") %>%  distinct(Reference) %>% nrow()
# in females
num_unique_studies_f <- table_data %>% filter(Included == "Yes" & `Measured in` == "Females") %>% distinct(Reference) %>% nrow()
# in males
num_unique_studies_m <- table_data %>% filter(Included == "Yes" & `Measured in` == "Males") %>% distinct(Reference) %>% nrow()

```

After this selection process, `r num_unique_traits` remain, that were measured across `r num_unique_studies` studies. There are `r num_unique_traits_f` measured in females and `r num_unique_traits_m` in males across `r num_unique_studies_f` and `r num_unique_studies_m` respectively.  

$~$

# Calculating *R*: the response to selection

$~$

We assume that line means approximate the breeding value for a trait for that given line, and that the variance across lines equals the genetic variance in the DGRP population for that trait.

We can then estimate the response to selection ($R$) for a trait using **Robertson's Secondary Theorem of Natural Selection** (also known as the **Robertson covariance**; Robertson, 1968), which states that $R$ is equivalent to the covariance between a traits breeding values ($A_z$) and the breeding values for relative fitness ($A_w$):

$$R = \sigma(A_w, Az)$$
The secondary theorem typically does not partition $R$ between the sexes. However, because we have $A_w$ values in both sexes and often $A_z$ values for each sex, we calculate four versions of $R$:

For traits expressed in females:

$$R_{FF} = \sigma(A_w^F, A_z^F)$$

and

$$R_{MF} = \sigma(A_w^M, A_z^F)$$
For traits expressed in males:

$$R_{MM} = \sigma(A_w^M, A_z^M)$$

and

$$R_{FM} = \sigma(A_w^F, A_z^M)$$

where the first subscripted letter indicates which sex breeding values for fitness were measured in.

$R_{MF}$ and $R_{FM}$ indicate the expected response when a trait is measured in one sex and fitness is measured in the other. We calculate these versions of $R$ because a trait can respond to selection acting on the other sex even if it is not expressed, because the phenotype is a multivariate amalgamation of traits and genetic correlations between traits are likely abundant. For example, alleles encoding a female-specific CHC may also effect male desiccation resistance, which could be under selection in males. 

$~$

## Build models to calculate $R_{FF}$ & $R_{MF}$

To estimate the covariance between $A_w$ and $A_z$, we fitted bivariate Bayesian linear models using the `brms` package (BÃ¼rkner, 2017) for `R version 4.2.2`. For each combination of trait and sex, we used line means for the focal trait and the fitness of the focal sex as the two response variables and fitted an intercept-only Gaussian model. Each model returned a posterior distribution of the residual correlation between trait and fitness, which for data expressed in standard units is equivalent to the covariance.

Build functions to run the models

```{r}

# RFF estimates

female_traits <- trait_data %>% filter(Sex == "Female")

trait_list_female <- unique(female_traits$Trait) # an input to the map_dfr() function that we'll need in a few chunks time

# code the model structure we will use for all traits using one example - `flight.performance.f`. We can then use the update() function to run this model many times, once for each trait measured in females. update() makes this process many times faster, because the model can immediately start sampling, without the need to recompile. 

RFF_model <-
  brm(data = female_traits %>% filter(Trait == "flight.performance.f"),
      family = gaussian,
      bf(mvbind(female_fitness, trait_value) ~ 1) + set_rescor(TRUE),
      prior = c(prior(normal(0, 0.1), class = Intercept, resp = femalefitness),
                prior(normal(0, 0.1), class = Intercept, resp = traitvalue),
                prior(normal(1, 0.1), class = sigma, resp = femalefitness),
                prior(normal(1, 0.1), class = sigma, resp = traitvalue),
                prior(lkj(2), class = rescor)),
      chains = 4, cores = 4, iter = 6000, warmup = 2000,
      seed = 1, file = "fits/RFF_test_model")   

# make a function to update the model and the posterior sample output with the 'selected trait'

RFF_calculator <- function(selected_trait){
  
  data <- female_traits %>% filter(Trait == selected_trait)
  
  model <- update(
    RFF_model, newdata = data,
      chains = 4, cores = 4, iter = 6000, warmup = 2000,
      seed = 1)
  
  posterior <- 
    as_draws_df(model) %>% 
    rename(Response_to_selection_female = rescor__femalefitness__traitvalue) %>% 
    mutate(Trait = selected_trait) %>% 
    select(Trait, Response_to_selection_female) %>% 
    as_tibble()
  
  posterior
}

# RMF estimates

RMF_model <-
  brm(data = female_traits %>% filter(Trait == "flight.performance.f"),
      family = gaussian,
      bf(mvbind(male_fitness, trait_value) ~ 1) + set_rescor(TRUE),
      prior = c(prior(normal(0, 0.1), class = Intercept, resp = malefitness),
                prior(normal(0, 0.1), class = Intercept, resp = traitvalue),
                prior(normal(1, 0.1), class = sigma, resp = malefitness),
                prior(normal(1, 0.1), class = sigma, resp = traitvalue),
                prior(lkj(2), class = rescor)),
      chains = 4, cores = 4, iter = 6000, warmup = 2000,
      seed = 1, file = "fits/RMF_test_model")

# make a function to update the model and the posterior sample output with your desired trait

RMF_calculator <- function(selected_trait){
  
  data <- female_traits %>% filter(Trait == selected_trait)
  
  model <- update(
    RMF_model, newdata = data,
    chains = 4, cores = 4, iter = 6000, warmup = 2000,
    seed = 1)
  
  posterior <- 
    as_draws_df(model) %>% 
    rename(Response_to_selection_male = rescor__malefitness__traitvalue) %>% 
    mutate(Trait = selected_trait) %>% 
    select(Trait, Response_to_selection_male) %>% 
    as_tibble()
  
  posterior
}

```

$~$

## Build models to calculate $R_{FM}$ & $R_{MF}$

$~$

```{r}

# RMM estimates

male_traits <- trait_data %>% filter(Sex == "Male")

trait_list_male <- unique(male_traits$Trait)

RMM_model <-
  brm(data = male_traits %>% filter(Trait == "flight.performance.m"),
      family = gaussian,
      bf(mvbind(male_fitness, trait_value) ~ 1) + set_rescor(TRUE),
      prior = c(prior(normal(0, 0.1), class = Intercept, resp = malefitness),
                prior(normal(0, 0.1), class = Intercept, resp = traitvalue),
                prior(normal(1, 0.1), class = sigma, resp = malefitness),
                prior(normal(1, 0.1), class = sigma, resp = traitvalue),
                prior(lkj(2), class = rescor)),
      chains = 4, cores = 4, iter = 6000, warmup = 2000,
      seed = 1, file = "fits/RMM_test_model")   

# make a function to update the model and the posterior sample output with your desired trait

RMM_calculator <- function(selected_trait){
  
  data <- male_traits %>% filter(Trait == selected_trait)
  
  model <- update(
    RMM_model, newdata = data,
    chains = 4, cores = 4, iter = 6000, warmup = 2000,
    seed = 1)
  
  posterior <- 
    as_draws_df(model) %>% 
    rename(Response_to_selection_male = rescor__malefitness__traitvalue) %>%
    mutate(Trait = selected_trait) %>% 
    select(Trait, Response_to_selection_male) %>% 
    as_tibble()
  
  posterior
}

# RFM estimates

RFM_model <-
  brm(data = male_traits %>% filter(Trait == "flight.performance.m"),
      family = gaussian,
      bf(mvbind(female_fitness, trait_value) ~ 1) + set_rescor(TRUE),
      prior = c(prior(normal(0, 0.1), class = Intercept, resp = femalefitness),
                prior(normal(0, 0.1), class = Intercept, resp = traitvalue),
                prior(normal(1, 0.1), class = sigma, resp = femalefitness),
                prior(normal(1, 0.1), class = sigma, resp = traitvalue),
                prior(lkj(2), class = rescor)),
      chains = 4, cores = 4, iter = 6000, warmup = 2000,
      seed = 1, file = "fits/RFM_test_model")   

# make a function to update the model and the posterior sample output with your desired trait

RFM_calculator <- function(selected_trait){
  
  data <- male_traits %>% filter(Trait == selected_trait)
  
  model <- update(
    RFM_model, newdata = data,
      chains = 4, cores = 4, iter = 6000, warmup = 2000,
      seed = 1)
  
  posterior <- 
    as_draws_df(model) %>% 
    rename(Response_to_selection_female = rescor__femalefitness__traitvalue) %>% 
    mutate(Trait = selected_trait) %>% 
    select(Trait, Response_to_selection_female) %>% 
    as_tibble()
  
  posterior
}
```

$~$

**Correlation ~ Covariance**

The `brms` model computes the posterior distribution of the residual correlation between standardised trait and fitness breeding values. Standardising traits to have standard deviation of 1 makes correlation equal to covariance. For our own sanity, we plot the residual correlation against covariance and show that, outside a small amount of noise at the extremes, correlation ~ covariance. We calculated point estimates of these variables for each trait measured in females using the `cor` and `cov` functions.

```{r}
cor_cov_calculator <- function(selected_trait){
  
  data <- trait_data %>% filter(Trait == selected_trait,
                                             !is.na(female_fitness),
                                             !is.na(trait_value))
  
  output <- 
    bind_cols(
      cor(data$female_fitness, data$trait_value) %>% 
        as_tibble() %>%
        rename(cor = value),
      
      
      cov(data$female_fitness, data$trait_value) %>% 
        as_tibble() %>%
        rename(cov = value)) %>% 
    mutate(Trait = selected_trait)
  
  output
}

cor_cov <- map_dfr(trait_list_female, cor_cov_calculator)

cor_cov %>% 
  ggplot(aes(cor, cov)) +
  geom_point(size = 2) +
  labs(x = "Trait correlation with fitness", y = "Trait covariance with fitness") +
  theme_bw() + 
  theme(text = element_text(size = 14))

```

$~$

## Run the models for all the traits

Run the models using `RFF_calculator`, `RMF_calculator`, `RMM_calculator` and `RFM_calculator`

```{r}
# run the RFF function

Run_function <- FALSE # Change this to TRUE to run the models

if(Run_function){
  RFF <- map_dfr(trait_list_female, RFF_calculator) # map_dfr returns a data frame created by row-binding each output
  write_csv(RFF, file = "data/RFF.csv")
} else RFF <- read_csv("data/RFF.csv")

# run the RMF function

if(Run_function){
  RMF <- map_dfr(trait_list_female, RMF_calculator) 
  write_csv(RMF, file = "data/RMF.csv")
} else RMF <- read_csv("data/RMF.csv")

# run the RMM function

if(Run_function){
  RMM <- map_dfr(trait_list_male, RMM_calculator) 
  write_csv(RMM, file = "data/RMM.csv")
} else RMM <- read_csv("data/RMM.csv")

# run the RFM function

if(Run_function){
  RFM <- map_dfr(trait_list_male, RFM_calculator) 
  write_csv(RFM, file = "data/RFM.csv")
} else RFM <- read_csv("data/RFM.csv")

```

$~$

# Interpreting R

## Calculate various metrics

$~$

Combine the data frames and estimate the overall expected response to selection as 

$$R_{overall}^F = \frac{R_{FF} + R_{MF}}{2}$$
and

$$R_{overall}^M = \frac{R_{MM} + R_{FM}}{2}$$

In the same code chunk, we also calculate the difference between the sexes for the response to selection in each trait as

$$\Delta R^F = R_{FF} - R_{MF}$$
and

$$\Delta R^M = R_{FM} - R_{MM}$$


to test for potential intralocus sexual conflict. Note that this measure does not reveal whether a trait is truly sexually antagonistic, as a difference is possible when a selection response is sexually concordant but with sex differences in strength. A difference can also result from the absence of a response in one sex and a strong response in the other. 

```{r}

R_female_traits <-
  bind_cols(RFF, RMF) %>% 
  filter(Trait...1 == Trait...3) %>% 
  rename(Trait = Trait...1) %>% 
  mutate(Trait_Sex = "Female",
         R_overall = (Response_to_selection_female + Response_to_selection_male)/2,
         R_diff = Response_to_selection_female - Response_to_selection_male) %>% 
    select(Trait, Trait_Sex, everything(), -(Trait...3)) 

R_male_traits <-
  bind_cols(RFM, RMM) %>% 
  rename(Trait = Trait...1) %>%  
  mutate(Trait_Sex = "Male",
         R_overall = (Response_to_selection_female + Response_to_selection_male)/2,
         R_diff = Response_to_selection_female - Response_to_selection_male) %>% 
  select(Trait, Trait_Sex, everything(), -(Trait...3)) %>% 
  filter(Trait != "dopamine.response.to.paraquat.2021.m")

R_all_traits <- bind_rows(R_female_traits, R_male_traits)

R_long_form <-
  R_all_traits %>% 
  select(1:4) %>% 
    pivot_longer(cols = 3:4, names_to = "Fitness_Sex", values_to = "R") %>% 
    mutate(Fitness_Sex = case_when(Fitness_Sex == "Response_to_selection_female" ~ "Female",
                                   Fitness_Sex == "Response_to_selection_male" ~ "Male"))

```

$~$

## Visualise the responses to selection for each trait

$~$

```{r, fig.height=30, fig.width=12}
p1 <-
  R_female_traits %>% 
  group_by(Trait) %>% 
  mutate(avg_R = median(Response_to_selection_female)) %>%
  ggplot(aes(Response_to_selection_female, fct_reorder(Trait, avg_R))) +
  stat_interval(.width = c(0.05, 0.66, 0.95), 
                height = 1, show.legend = F) +
  rcartocolor::scale_color_carto_d(palette = "Purp") +
  coord_cartesian(xlim = c(-0.5, 0.5)) +
  geom_vline(linetype = 2, xintercept = 0, linewidth = 1) +
  labs(x = "Response to selection in females",
       y = "Trait expressed in females") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank(),
        text = element_text(size=14),
        axis.text.y = element_text(size = 8))

p2 <-
  R_female_traits %>% 
  group_by(Trait) %>% 
  mutate(avg_R = median(Response_to_selection_male)) %>%
  ggplot(aes(Response_to_selection_male, fct_reorder(Trait, avg_R))) +
  stat_interval(.width = c(0.05, 0.66, 0.95), 
                height = 1, show.legend = F) +
  rcartocolor::scale_color_carto_d(palette = "Peach") +
  coord_cartesian(xlim = c(-0.5, 0.5)) +
  geom_vline(linetype = 2, xintercept = 0, linewidth = 1) +
  labs(x = "Response to selection in males",
       y = "Trait expressed in females") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank(),
        text = element_text(size=14),
        axis.text.y = element_text(size = 8)) 


p1 + p2 +
  plot_annotation(tag_levels = 'a')

```

**Figure S1**. The estimated response to selection in **a** females and **b** males for all traits measured in females. Innermost bands approximate the median, while outer bands show the 66 and 95% credible intervals.

$~$

```{r, fig.height=30, fig.width=12}

p3 <-
  R_male_traits %>% 
  group_by(Trait) %>% 
  mutate(avg_R = median(Response_to_selection_male)) %>%
  ggplot(aes(Response_to_selection_male, fct_reorder(Trait, avg_R))) +
  stat_interval(.width = c(0.05, 0.66, 0.95), 
                height = 1, show.legend = F) +
  rcartocolor::scale_color_carto_d(palette = "Peach") +
  coord_cartesian(xlim = c(-0.5, 0.5)) +
  geom_vline(linetype = 2, xintercept = 0, linewidth = 1) +
  labs(x = "Response to selection in males",
       y = "Trait expressed in males") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank(),
        text = element_text(size=14),
        axis.text.y = element_text(size = 8))

p4 <- 
  R_male_traits %>% 
  group_by(Trait) %>% 
  mutate(avg_R = median(Response_to_selection_female)) %>%
  ggplot(aes(Response_to_selection_female, fct_reorder(Trait, avg_R))) +
  stat_interval(.width = c(0.05, 0.66, 0.95), 
                height = 1, show.legend = F) +
  rcartocolor::scale_color_carto_d(palette = "Purp") +
  coord_cartesian(xlim = c(-0.5, 0.5)) +
  geom_vline(linetype = 2, xintercept = 0, linewidth = 1) +
  labs(x = "Response to selection in females",
       y = "Trait expressed in males") +
  theme_bw() + 
  theme(legend.position = "none",
        panel.grid.minor = element_blank(),
        text = element_text(size=14),
        axis.text.y = element_text(size = 8)) 




p3 + p4 +
  plot_annotation(tag_levels = 'a')

```

**Figure S2**. The response to selection in **a** males and **b** females for all traits measured in males. Innermost bands approximate the median, while outer bands show the 66 and 95% credible intervals.

$~$

Choose the notable traits measured in females in terms of absolute $R_{FF}$ and $R_{MF}$ and present them in a Table

**Table 1**. The traits measured in females with the strongest responses to selection on females (left column) and males (right column) in the DGRP. The sign of $R$ indicates the direction of the response, with positive expected responses bolded. Estimated error is the standard deviation of the posterior distribution. The notable column indicates that the 95% CI does not overlap zero.

```{r}
R_summary_female <-
bind_cols(
  R_female_traits %>% 
    select(Trait, Response_to_selection_female) %>% 
    group_by(Trait) %>% 
    summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
    ungroup() %>% 
    left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names
    rename(`R in females` = median, `Estimated error` = sd,
           `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`, `Trait in females` = Trait_nice)  %>% 
    mutate(R_abs = abs(`R in females`)) %>% 
    arrange(-R_abs) %>% 
    mutate(across(3:6, ~ round(.x, digits = 3)),
           Notable = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                               `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                               TRUE ~ " ")) %>% 
    filter(Notable == "*") %>% 
    mutate(`Trait value` = if_else(`R in females` < 0, "Decreasing", "Increasing")) %>% 
    select(`Trait in females`, `Trait value`, `R in females`, `Estimated error`, 
           `2.5% CI`, `97.5% CI`, Notable) %>% 
    #the next lines add empty rows and remove the NA values in them. We do this so we bind the two dataframes 
    add_row() %>%
    add_row() %>%
    add_row() %>%
    mutate_all(~replace(., is.na(.), "")),
  
  R_female_traits %>% 
    select(Trait, Response_to_selection_male) %>% 
    group_by(Trait) %>% 
    summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
    ungroup() %>% 
    left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names
    rename(`R in males` = median, `Estimated error ` = sd,
           `2.5% CI ` = `2.5%`, `97.5% CI ` = `97.5%`, `Trait in females ` = Trait_nice)  %>% 
    mutate(R_abs = abs(`R in males`)) %>% 
    arrange(-R_abs) %>% 
    mutate(across(3:6, ~ round(.x, digits = 3)),
           `Notable ` = case_when(`2.5% CI ` < 0 & `97.5% CI ` < 0 ~ "*",
                                 `2.5% CI ` > 0 & `97.5% CI ` > 0 ~ "*",
                                 TRUE ~ " ")) %>% 
    filter(`Notable ` == "*") %>% 
    mutate(`Trait value ` = if_else(`R in males` < 0, "Decreasing", "Increasing")) %>%
    select(`Trait in females `, `Trait value `, `R in males`, `Estimated error `, `2.5% CI `, `97.5% CI `, `Notable `)
) 
  
  kbl(R_summary_female) %>%
  kable_minimal(font_size = 12) %>% 
  column_spec(1,
              bold = if_else(R_summary_female$`R in females` > 0, TRUE, FALSE),
              width = "22em") %>% 
  column_spec(7,
              bold = if_else(R_summary_female$`R in males` > 0, TRUE, FALSE),
              width = "24em") 

#make_table_no_linespaces(R_summary_female_f)
```

$~$

**Table 2**. The traits in measured in males with the strongest responses to selection on females (left column) and males (right column) in the DGRP. The sign of $R$ indicates the direction of the response, with positive expected responses bolded. Estimated error is the standard deviation of the posterior distribution. The notable column indicates that the 95% CI does not overlap zero.

```{r}
R_summary_male <-
 bind_cols(
    R_male_traits %>% 
      select(Trait, Response_to_selection_female) %>% 
      group_by(Trait) %>% 
      summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
      ungroup() %>% 
      left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names
      rename(`R in females` = median, `Estimated error` = sd,
             `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`, `Trait in males` = Trait_nice)  %>% 
      mutate(R_abs = abs(`R in females`)) %>% 
      arrange(-R_abs) %>% 
      mutate(across(3:6, ~ round(.x, digits = 3)),
             Notable = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                 `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                 TRUE ~ " ")) %>% 
      filter(Notable == "*") %>% 
   mutate(`Trait value` = if_else(`R in females` < 0, "Decreasing", "Increasing")) %>%
      select(`Trait in males`, `Trait value`, `R in females`, `Estimated error`, `2.5% CI`, `97.5% CI`, Notable) %>% 
      # the next lines add empty rows and remove the NA values in them. We do this so we bind the two dataframes 
      add_row() %>% 
      add_row() %>%
      add_row() %>%
      add_row() %>%
      add_row() %>%
      add_row() %>%
      add_row() %>%
      add_row() %>%
      add_row() %>%
      add_row() %>%
      add_row() %>%
      add_row() %>%
      mutate_all(~replace(., is.na(.), "")),
   
  R_male_traits %>% 
  select(Trait, Response_to_selection_male) %>% 
  group_by(Trait) %>% 
  summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
  ungroup() %>% 
  left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names
  rename(`R in males` = median, `Estimated error ` = sd,
         `2.5% CI ` = `2.5%`, `97.5% CI ` = `97.5%`, `Trait in males ` = Trait_nice)  %>% 
  mutate(R_abs = abs(`R in males`)) %>% 
  arrange(-R_abs) %>% 
  mutate(across(3:6, ~ round(.x, digits = 3)),
         `Notable ` = case_when(`2.5% CI ` < 0 & `97.5% CI ` < 0 ~ "*",
                               `2.5% CI ` > 0 & `97.5% CI ` > 0 ~ "*",
                               TRUE ~ " ")) %>% 
  filter(`Notable ` == "*") %>% 
     mutate(`Trait value ` = if_else(`R in males` < 0, "Decreasing", "Increasing")) %>%
  select(`Trait in males `, `Trait value `, `R in males`, `Estimated error `, `2.5% CI `, `97.5% CI `, `Notable `)
  )


kbl(R_summary_male) %>%
  kable_minimal(font_size = 12) %>% 
  column_spec(1,
              bold = if_else(R_summary_male$`R in females` > 0, TRUE, FALSE),
              width = "22em") %>% 
  column_spec(7,
              bold = if_else(R_summary_male$`R in males` > 0, TRUE, FALSE),
              width = "28em")  

#make_table_no_linespaces(R_summary_male_f)
```

**Table S2**. Traits with the strongest overall responses to selection in the DGRP (total traits measured = 232 in females and 242 in males). The sign of $R$ indicates the direction of the response, with positive expected responses bolded. Estimated error is the standard deviation of the posterior distribution. The notable column indicates whether the 95% CI overlaps with zero.

```{r}

R_total_summary <-
  bind_rows(
    left_join(
      R_female_traits %>% 
        select(Trait, R_overall) %>% 
        group_by(Trait) %>% 
        summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
        ungroup() %>% 
        left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names
        rename(`R overall` = median, `Estimated error` = sd,
               `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`)  %>% 
        mutate(R_abs = abs(`R overall`)) %>% 
        arrange(-R_abs) %>% 
        mutate(across(3:6, ~ round(.x, digits = 3)),
               Notable = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                   `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                   TRUE ~ " ")) %>% 
        filter(Notable == "*"),
      
      R_female_traits %>% 
        select(Trait, Trait_Sex, Response_to_selection_female, Response_to_selection_male) %>% 
        group_by(Trait, Trait_Sex) %>% 
        summarise(`R in females` = round(median(Response_to_selection_female), 3),
                  `R in males` = round(median(Response_to_selection_male), 3)) %>% 
        ungroup()
    ) %>% 
      select(Trait_nice, Trait_Sex, `R in females`, `R in males`, `R overall`, `Estimated error`, `2.5% CI`, `97.5% CI`, Notable) %>% 
      rename(Trait = Trait_nice, `Trait sex` = Trait_Sex),
    
     left_join(
      R_male_traits %>% 
        select(Trait, R_overall) %>% 
        group_by(Trait) %>% 
        summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
        ungroup() %>% 
        left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names
        rename(`R overall` = median, `Estimated error` = sd,
               `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`)  %>% 
        mutate(R_abs = abs(`R overall`)) %>% 
        arrange(-R_abs) %>% 
        mutate(across(3:6, ~ round(.x, digits = 3)),
               Notable = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                   `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                   TRUE ~ " ")) %>% 
        filter(Notable == "*"),
      
      R_male_traits %>% 
        select(Trait, Trait_Sex, Response_to_selection_female, Response_to_selection_male) %>% 
        group_by(Trait, Trait_Sex) %>% 
        summarise(`R in females` = round(median(Response_to_selection_female), 3),
                  `R in males` = round(median(Response_to_selection_male), 3)) %>% 
        ungroup()
    ) %>% 
      select(Trait_nice, Trait_Sex, `R in females`, `R in males`, `R overall`, `Estimated error`, `2.5% CI`, `97.5% CI`, Notable) %>% 
      rename(Trait = Trait_nice,
             `Trait sex` = Trait_Sex)
  ) %>% 
  select(Trait, `R overall`, everything())
    

kbl(R_total_summary %>% select(-`Trait sex`)) %>%
  kable_minimal(full_width = F, font_size = 12) %>% 
  column_spec(1,
              bold = if_else(R_total_summary$`R overall` > 0, TRUE, FALSE),
              width = "21em")%>% 
  pack_rows("Traits measured in females", 1, 31, hline_after = TRUE, italic = TRUE) %>% 
  pack_rows("Traits measured in males", 32, 52, hline_after = TRUE, italic = TRUE)


```

$~$

**Table 3**. The traits with the largest $\Delta R$ between the sexes in the DGRP. Traits where $R_F > R_M$ are indicated in bold. Estimated error is the standard deviation of the posterior distribution. The notable column indicates whether the 95% CI overlaps with zero.

```{r}

R_diff_summary <-
  bind_rows(
    left_join(
      R_female_traits %>% 
        select(Trait, R_diff) %>% 
        group_by(Trait) %>% 
        summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
        ungroup() %>% 
        left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names
        rename(`Female R - Male R` = median, `Estimated error` = sd,
               `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`)  %>% 
        mutate(R_abs = abs(`Female R - Male R`)) %>% 
        arrange(-R_abs) %>% 
        mutate(across(3:6, ~ round(.x, digits = 3)),
               Notable = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                   `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                   TRUE ~ " ")) %>% 
        filter(Notable == "*"),
      
      R_female_traits %>% 
        select(Trait, Response_to_selection_female, Response_to_selection_male) %>% 
        group_by(Trait) %>% 
        summarise(`R in females` = round(median(Response_to_selection_female), 3),
                  `R in males` = round(median(Response_to_selection_male), 3)) %>% 
        ungroup()
    ) %>% 
      select(Trait_nice, `R in females`, `R in males`, `Female R - Male R`, `Estimated error`, `2.5% CI`, `97.5% CI`, Notable) %>% 
      rename(Trait = Trait_nice),
    
    left_join(
    R_male_traits %>% 
      select(Trait, R_diff) %>% 
      group_by(Trait) %>% 
      summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
      ungroup() %>% 
      left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names
      rename(`Female R - Male R` = median, `Estimated error` = sd,
             `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`)  %>% 
      mutate(R_abs = abs(`Female R - Male R`)) %>% 
      arrange(-R_abs) %>% 
      mutate(across(3:6, ~ round(.x, digits = 3)),
             Notable = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                 `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                 TRUE ~ " ")) %>% 
      filter(Notable == "*"),
    
    R_male_traits %>% 
      select(Trait, Response_to_selection_female, Response_to_selection_male) %>% 
      group_by(Trait) %>% 
      summarise(`R in females` = round(median(Response_to_selection_female), 3),
                `R in males` = round(median(Response_to_selection_male), 3)) %>% 
      ungroup()
  ) %>% 
  select(Trait_nice, `R in females`, `R in males`, `Female R - Male R`, `Estimated error`, `2.5% CI`, `97.5% CI`, Notable) %>% 
  rename(Trait = Trait_nice) %>% 
  filter(!is.na(Trait))
  ) %>% 
  select(Trait, `Female R - Male R`, everything())


kbl(R_diff_summary) %>%
  kable_minimal(full_width = F, font_size = 12) %>% 
  column_spec(1,
              bold = if_else(R_diff_summary$`Female R - Male R` > 0, TRUE, FALSE),
              width = "21em") %>% 
  pack_rows("Traits measured in females", 1, 8, hline_after = TRUE, italic = TRUE) %>% 
  pack_rows("Traits measured in males", 9, 18, hline_after = TRUE, italic = TRUE)

```

$~$

## Build Figure 2

```{r, fig.height=8}
female_R_diff_plot <-
  R_female_traits %>%
  group_by(Trait) %>%
  mutate(diff_mean = mean(R_diff)) %>%
  ungroup() %>%
  filter(diff_mean > 0.26 | diff_mean < -0.26) %>%
  left_join(clean_meta_data) %>%
  filter(!is.na(Trait_nice)) %>%
  #filter(!str_detect(Trait_nice, "environment")) %>%
  #filter(!str_detect(Trait_nice, "SD")) %>%
  select(Response_to_selection_female, Response_to_selection_male, Trait_nice) %>%
  rename(Female = Response_to_selection_female, Male = Response_to_selection_male) %>%
  pivot_longer(cols = 1:2, names_to = "Fitness_Sex", values_to = "R") %>%
  mutate(Trait_nice = case_when(Trait_nice == "DDT resistance mortality" ~
                                  "DDT susceptibility",
                                Trait_nice == "CHC 6,10-C26:2" ~
                                  "CHC 6,10-C26:2 peak",
                                .default = Trait_nice)) %>% 


  ggplot(aes(x = R, y = Trait_nice, fill = Fitness_Sex)) +
  stat_slab(alpha = 0.9, shape = 21) +#,
  labs(x = expression("The expected response to selection, "* italic(R)),
       y = NULL,
       fill = "Sex under selection",
       subtitle = "a. Measured in females") +
  geom_vline(xintercept = 0, linetype = 2, linewidth = 1.2) +
  scale_fill_manual(values = c(carto_pal(7, "Purp")[5], carto_pal(7, "Peach")[5])) +
  coord_cartesian(xlim = c(-0.6, 0.6)) +
  theme_minimal() +
  theme(panel.background = element_rect(fill='transparent'),
        #panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        plot.background = element_rect(fill='transparent', color=NA),
        legend.position = "none",
        text = element_text(size=12),
        axis.text.y = element_text(size = 9),
        plot.subtitle=element_text(hjust=0.5))

male_R_diff_plot <-
  R_male_traits %>%
  group_by(Trait) %>%
  mutate(diff_mean = mean(R_diff)) %>%
  ungroup() %>%
  filter(diff_mean > 0.28 | diff_mean < -0.28) %>%
  left_join(clean_meta_data) %>%
  filter(!is.na(Trait_nice)) %>%
  #filter(!str_detect(Trait_nice, "environment")) %>%
  #filter(!str_detect(Trait_nice, "SD")) %>%
  select(Response_to_selection_female, Response_to_selection_male, Trait_nice) %>%
  rename(Female = Response_to_selection_female, Male = Response_to_selection_male) %>%
  pivot_longer(cols = 1:2, names_to = "Fitness_Sex", values_to = "R") %>%


  ggplot(aes(x = R, y = Trait_nice, fill = Fitness_Sex)) +
  stat_slab(alpha = 0.9, shape = 21) +#,
  labs(x = expression("The expected response to selection, "* italic(R)),
       y = NULL,
       fill = "Sex under selection",
       subtitle = "b. Measured in males") +
  geom_vline(xintercept = 0, linetype = 2, linewidth = 1.2) +
  scale_fill_manual(values = c(carto_pal(7, "Purp")[5], carto_pal(7, "Peach")[5])) +
  coord_cartesian(xlim = c(-0.6, 0.6)) +
  theme_minimal() +
  theme(panel.background = element_rect(fill='transparent'),
        #panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        plot.background = element_rect(fill='transparent', color=NA),
        legend.position = "bottom",
        text = element_text(size=12),
        axis.text.y = element_text(size = 9),
        plot.subtitle=element_text(hjust=0.5))

fig2 <- female_R_diff_plot / male_R_diff_plot

fig2
```

**Figure 2**. Candidate traits predicted to have strong sex-specific responses to selection. The traits shown are those where the 95% credible interval of the difference between $R_f$ and $R_m$ does not overlap zero. Traits are likely to have sex-specific genetic architectures, therefore we consider traits measured in females as distinct from traits measured in males, and _vice versa_, even if they are putatively the same e.g. mean lifespan. Hence, mating latency is measured in males (panel b), but $R$ can be estimated for both sexes, because we simply need the genetic covariance between trait and fitness. Detailed definitions of each trait are given in Table S1.  

$~$

# Estimate across-trait grand means for $|R|$ in each sex

```{r, eval=FALSE}
# First, fit a simple model to estimate the overall absolute response, |$R_{overall}$| across traits

R_overall_medians <-
  R_all_traits %>% 
  select(Trait, Trait_Sex, R_overall) %>% 
  group_by(Trait, Trait_Sex) %>% 
  summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>% 
  ungroup() %>% 
  select(-variable) %>% 
  left_join(clean_meta_data) %>% 
  mutate(absolute_R_overall = abs(median),
         Trait_Sex = as.factor(Trait_Sex),
         Trait = as.factor(Trait)) 

R_intercept_model <- 
  brm(absolute_R_overall | weights(1/sd) ~ 1 + Trait_Sex + (1|study_ID),
      family = brmsfamily(family = "Gamma"), # gamma is appropriate for the half-normal distribution created by taking the absolute
      data = R_overall_medians,
      prior = c(prior(normal(-2.2, 1), class = Intercept),
                prior(exponential(1), class = sd),
                prior(exponential(1), class = shape),
                prior(normal(0, 0.25), class = b)),
      warmup = 4000, iter = 12000,
      seed = 1, cores = 4, chains = 4,
      control = list(adapt_delta = 0.9, max_treedepth = 10),
      file = "fits/intercept_R_model")

print(R_intercept_model)

```


```{r, eval=FALSE}
# Find summary measures to report in results section
new_data <- tibble(Trait_Sex = c("Female", "Male"))

  fitted(R_intercept_model, newdata = new_data, re_formula = NA, summary = F) %>% 
  as.data.frame() %>% 
  rename(Female_trait_R = V1, Male_trait_R = V2) %>% 
  as_tibble() %>% 
  mutate(percent_diff = ((Female_trait_R - Male_trait_R) / Male_trait_R)*100) %>% 
  pivot_longer(cols = everything(), names_to = "Parameter", values_to = "R_mean") %>% 
  group_by(Parameter) %>% 
  median_qi(R_mean)

```

$~$

Fit the model to test whether $|R|$ depends on the sex fitness and trait values were measured in:

```{r}

R_medians <-
  R_long_form %>%
  group_by(Trait, Fitness_Sex, Trait_Sex) %>% 
  summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>% 
  ungroup() %>% 
  select(-variable) %>% 
  left_join(clean_meta_data) %>% 
  mutate(absolute_R = abs(median),
         Fitness_Sex = as.factor(Fitness_Sex),
         Trait_Sex = as.factor(Trait_Sex),
         Trait = as.factor(Trait)) 

median_R_model <- 
  brm(absolute_R | weights(1/sd) ~ 1 + Fitness_Sex * Trait_Sex + (1|study_ID) + (1|Trait),
      family = brmsfamily(family = "Gamma"), # gamma is appropriate for the half-normal distribution created by taking the absolute
      data = R_medians,
      prior = c(prior(normal(-2.2, 1), class = Intercept),
                prior(exponential(1), class = sd),
                prior(exponential(1), class = shape),
                prior(normal(0, 0.25), class = b)),
      warmup = 4000, iter = 12000,
      seed = 1, cores = 4, chains = 4,
      control = list(adapt_delta = 0.9, max_treedepth = 10),
      file = "fits/median_R_model")

print(median_R_model)
```

$~$

## Build Figure 3

Get model predictions and plot

```{r, fig.width=10, fig.height=5}

new_data <- expand_grid(Fitness_Sex = c("Female", "Male"),
                        Trait_Sex = c("Female", "Male"))

R_fitted <-
  fitted(median_R_model, newdata = new_data, re_formula = NA, summary = F) %>% 
  as.data.frame() %>% 
  rename(FemaleFitness_FemaleTrait = V1, FemaleFitness_MaleTrait = V2, 
         MaleFitness_FemaleTrait = V3, MaleFitness_MaleTrait = V4) %>% 
  as_tibble() %>% 
  mutate(percent_diff_female = ((MaleFitness_FemaleTrait - FemaleFitness_FemaleTrait) / FemaleFitness_FemaleTrait)*100,
         percent_diff_male = ((MaleFitness_MaleTrait - FemaleFitness_MaleTrait)/ FemaleFitness_MaleTrait)*100) %>% 
  pivot_longer(cols = everything(), names_to = "Parameter", values_to = "R_mean") %>% 
  mutate(Fitness_Sex = case_when(str_detect(Parameter, "FemaleFitness") ~ "Female",
                                 str_detect(Parameter, "MaleFitness") ~ "Male"),
         Trait_Sex = case_when(str_detect(Parameter, "FemaleTrait") ~ "Female",
                               str_detect(Parameter, "MaleTrait") ~ "Male",
                               str_detect(Parameter, "percent_diff_female") ~ "Female",
                               str_detect(Parameter, "percent_diff_male") ~ "Male"))


R_p1 <-
  R_fitted %>% 
  filter(!str_detect(Parameter, "percent")) %>% 
  ggplot(aes(x = R_mean, y = Trait_Sex, fill = Fitness_Sex)) + #fill = Fitness_Sex)) +
  stat_slab(alpha = 0.9, shape = 21) +#,
  labs(x = expression("Across-trait estimated magnitude for |"* italic(R) * "|"),
       y = "Sex traits were measured in",
       fill = "Sex under selection") +
  scale_fill_manual(values = c(carto_pal(7, "Purp")[5], carto_pal(7, "Peach")[5])) +
  theme_minimal() + 
  theme(panel.background = element_rect(fill='transparent'),
        #panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        plot.background = element_rect(fill='transparent', color=NA),
        legend.position = "bottom",
        text = element_text(size=13))

R_p2 <-
  R_fitted %>% 
  filter(str_detect(Parameter, "percent")) %>%
  ggplot(aes(x = R_mean, y = Trait_Sex, fill = Trait_Sex)) +
  stat_halfeye(.width = c(0.66, 0.95), alpha = 0.9,
               point_interval = "median_qi", point_fill = "white",
               shape = 21, point_size = 4, stroke = 1.5) + # width indicates the uncertainty intervals: here we have 66% and 95% intervals + # width indicates the uncertainty intervals: here we have 66% and 95% intervals+
  scale_fill_manual(values = c(carto_pal(7, "Peach")[5], carto_pal(7, "Peach")[5], carto_pal(7, "Purp")[5])) +
  geom_vline(xintercept = 0, linetype = 2, linewidth = 1.2) +
  coord_cartesian(xlim = c(-5, 50)) +
  xlab(expression("% increase in |"*italic(R)* "| through males")) +
  ylab("Sex traits were measured in") +
  theme_minimal() + 
  theme(panel.background = element_rect(fill='transparent'),
        #panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        plot.background = element_rect(fill='transparent', color=NA),
        legend.position = "none",
        text = element_text(size=13))

R_p1 + R_p2 +
  plot_annotation(tag_levels = 'a')
  
```

**Figure 3**. **a** The posterior distribution for across-trait |$R$|, the mean expected
response to selection (absolute value) in females and males and split by the sex the
trait was measured in. For each trait $R = \sigma(A_w, A_z)$, where Aw is the breeding
value for fitness and $A_z$ is the trait breeding value. |$R$| is expressed in trait standard
deviations. **b** The percentage increase in |$R$| through males compared to through
females. Points indicate the estimated median with associated 66 and 95% credible
intervals.

$~$

**Calculating stats for the results section**

```{r}
R_fitted %>% 
  group_by(Parameter) %>% 
  median_qi(R_mean)
```

$~$

# Identifying traits responding to sexually antagonistic selection

## Innocenti and Morrow's I index

$~$

We have found $R$ for traits in females and males. For those traits where we have a measure of both, we can estimate the concordance of the response to selection between the sexes using the $I$ metric presented in [Innocenti and Morrow (2011)]( https://doi.org/10.1111/j.1558-5646.2010.01021.x).

$$I = \frac{\beta'_M \beta'_F}{\sqrt{\frac{(\beta'_M)^2 + (\beta'_F)^2}{2}}}$$

Where $\beta'_F$ and $\beta'_M$ = are phenotypic selection gradients. Taking traits expressed in females as an example, we substitute $R_FF$ and $R_MF$ for $\beta'_F$ and $\beta'_M$. This makes our test for sexually antagonistic traits more conservative, as non-zero $R$ requires both directional selection on the trait and the presence of additive genetic variance for the trait. 

This index is positive when selection is concordant in the two sexes, negative when antagonistic in the two sexes, and is zero when selection is absent in one sex (note that it will miss conflict that occurs when strong stabilizing selection is present in that sex). Finally it is proportional to the absolute intensity of selection (track the diagonals in the visualisation below to get a sense of this). Note that because we use $R$ instead of $\beta'$, $I$ is bounded between -1 to 1 in our analysis.  

Additionally, it is symmetrical and normally distributed for a random set of normally distributed $\beta'_M$, $\beta'_F$. $|I|$ is also always included in the interval between the absolute values of the selection gradient in the two sexes, and it coincides with them when $\beta'_M = \beta'_F$. As a potential drawback, it should be noted that such quantity is not defined when $\beta'_M = \beta'_F = 0$.
 
First let's look at the $I$ parameter space. We simulate combinations of $R_F$ and $R_M$ and calculate $I$.
 
```{r}
# Let's test that the I index behaves as it should

sim_I <-
  expand_grid(R_F = seq(from = -0.5, to = 0.5, by = 0.01),
         R_M = seq(from = -0.5, to = 0.5, by = 0.01)) %>% 
  mutate(I = R_F * R_M / sqrt(((R_F)^2 + (R_M)^2)/2))

I_plot <-
  sim_I %>% 
  ggplot(aes(x = R_F, y = R_M, fill = I)) +
  geom_raster() +
  stat_contour(aes(z = I), colour = "black", binwidth = 0.075) +
  stat_contour(aes(z = I), colour = "black", breaks = 8, linetype = 2) +
  scale_fill_gradientn(colours = met.brewer(name = "Paquin", 7),
                       labels = c("Antagonistic", -0.25, 0, 0.25, "Concordant")) +
  scale_x_continuous(expand = c(0, 0)) + 
  scale_y_continuous(expand = c(0, 0)) +
  labs(x = "Response to selection in females", y = "Response to selection in males", fill = "I index") +
  theme_tidybayes() +
  theme(text = element_text(size = 17),
        legend.position = "right",
        legend.direction = "vertical")

I_plot
```
 
Calculate $I$ for each draw of each trait

**Table S4**. The traits with the most concordant and antagonistic _I_ index values in the DGRP. Estimated error is the standard deviation of the posterior distribution. The notable column indicates whether the 95% CI overlaps with zero.
 
```{r}

I_index <-
  R_all_traits %>% 
  mutate(I = Response_to_selection_female * Response_to_selection_male / 
           sqrt(((Response_to_selection_female)^2 + (Response_to_selection_male)^2)/2))
# make the tables

bind_cols(
  bind_rows(
    I_index %>% 
      filter(Trait_Sex == "Female") %>% 
      select(Trait, I) %>% 
      group_by(Trait) %>% 
      summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
      ungroup() %>% 
      rename(I = median, `Estimated error` = sd, `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`)  %>%
      arrange(-I) %>% 
      slice_head(n = 20) %>% 
      select(-variable) %>% 
      mutate(across(I:`97.5% CI`, ~ round(.x, digits = 3)),
             `Notable` = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                   `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                   TRUE ~ " ")) %>% #, 
      left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names 
      rename(`Trait in females` = Trait_nice) %>% 
      select(`Trait in females`, everything(), -Trait),
    
    
    I_index %>% 
      filter(Trait_Sex == "Female") %>% 
      select(Trait, I) %>% 
      group_by(Trait) %>% 
      summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
      ungroup() %>% 
      rename(I = median, `Estimated error` = sd, `2.5% CI` = `2.5%`, `97.5% CI` = `97.5%`)  %>%
      arrange(I) %>% 
      slice_head(n = 20) %>% 
      select(-variable) %>% 
      mutate(across(I:`97.5% CI`, ~ round(.x, digits = 3)),
             `Notable` = case_when(`2.5% CI` < 0 & `97.5% CI` < 0 ~ "*",
                                   `2.5% CI` > 0 & `97.5% CI` > 0 ~ "*",
                                   TRUE ~ " ")) %>% 
      left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names 
      rename(`Trait in females` = Trait_nice) %>% 
      select(`Trait in females`, everything(), -Trait) 
  ),
  
  bind_rows(
    I_index %>% 
      filter(Trait_Sex == "Male") %>% 
      select(Trait, I) %>% 
      group_by(Trait) %>% 
      summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
      ungroup() %>% 
      rename(`I ` = median, `Estimated error ` = sd, `2.5% CI ` = `2.5%`, `97.5% CI ` = `97.5%`)  %>%
      arrange(-`I `) %>% 
      slice_head(n = 20) %>% 
      select(-variable) %>% 
      mutate(across(`I `:`97.5% CI `, ~ round(.x, digits = 3)),
             `Notable ` = case_when(`2.5% CI ` < 0 & `97.5% CI ` < 0 ~ "*",
                                    `2.5% CI ` > 0 & `97.5% CI ` > 0 ~ "*",
                                    TRUE ~ " ")) %>% 
      left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names 
      rename(`Trait in males` = Trait_nice) %>% 
      select(`Trait in males`, everything(), -Trait), 
    
    I_index %>% 
      filter(Trait_Sex == "Male") %>% 
      select(Trait, I) %>%  
      group_by(Trait) %>% 
      summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
      ungroup() %>% 
      select(-variable) %>% 
      rename(`I ` = median, `Estimated error ` = sd, `2.5% CI ` = `2.5%`, `97.5% CI ` = `97.5%`)  %>%
      arrange(`I `) %>% 
      slice_head(n = 20) %>% 
      mutate(across(`I `:`97.5% CI `, ~ round(.x, digits = 3)),
             `Notable ` = case_when(`2.5% CI ` < 0 & `97.5% CI ` < 0 ~ "*",
                                    `2.5% CI ` > 0 & `97.5% CI ` > 0 ~ "*",
                                    TRUE ~ " ")) %>% 
      left_join(trait_data %>% distinct(Trait, Trait_nice)) %>% # add the nice names 
      rename(`Trait in males` = Trait_nice) %>% 
      select(`Trait in males`, everything(), -Trait) #%>% 
      #filter(!is.na(`Trait in males`))
  )
) %>% 
  
  
  
  kbl() %>%
  kable_minimal(full_width = F, font_size = 12) %>% 
  column_spec(1, width = "27em") %>% 
  pack_rows("Sexually concordant R", 1, 20, italic = TRUE) %>% 
  pack_rows("Sexually antagonistic R", 21, 40, italic = TRUE) %>% 
  column_spec(7, width = "27em")

```

Build panel a for Figure 4.

```{r}

I_summary <- 
  I_index %>% 
  group_by(Trait, Trait_Sex) %>% 
  summarise(R_F = median(Response_to_selection_female),
            R_M = median(Response_to_selection_male),
            I = median(I)) %>%
  ungroup() %>% 
  mutate(I_abs = abs(I),
         Trait_Sex = case_when(Trait_Sex == "Female" ~ "Traits measured in females",
                               Trait_Sex == "Male" ~ "Traits measured in males")) %>% 
  left_join(trait_data %>% distinct(Trait, Trait_nice))

I_plot_labelled <-
  I_plot +
  new_scale_fill() +
  geom_point(data = I_summary, #%>% filter(Trait_Sex == "Female"),
             aes(x = R_F, y = R_M, fill = Trait_Sex),
             size = 4, alpha = 0.75, shape = 21) +
  scale_fill_manual(values = c("Female" = "white", "Male" = "lightblue")) +
  labs(fill = "Sex measured in") +
  new_scale_fill() +
  geom_label_repel(data = I_summary %>% filter(I_abs > 0.15),  
                   aes(label = Trait_nice, fill = if_else(I > 0, met.brewer(name = "Paquin", 7)[3], met.brewer(name = "Paquin", 7)[5])), size = 3, alpha = 0.9,
                   min.segment.length = 0, seed = 1, box.padding = 0.5, point.padding = 0.5) +
  scale_fill_manual(values = c(met.brewer(name = "Paquin", 7)[3], met.brewer(name = "Paquin", 7)[5]), guide = "none")

   
fig4_panel_a <-
  I_summary %>%
  ggplot(aes(x = R_F, y = R_M)) +
  geom_point(aes(fill = I),
             size = 4, alpha = 0.75, shape = 21) +
  geom_hline(yintercept = 0, linetype = 2) +
  geom_vline(xintercept = 0, linetype = 2) +
  scale_fill_gradientn(colours = met.brewer(name = "Paquin", 7),
                       limits = c(-0.3, 0.3)) +
  guides(fill = guide_colourbar(barwidth = 8, barheight = 0.5)) +
  labs(x = "Reponse to selection on females",
       y = "Reponse to selection on males",
       fill = "_I_ index") +
  coord_cartesian(xlim = c(-0.4, 0.4), ylim = c(-0.4, 0.4)) +
  facet_wrap(~Trait_Sex) +
  theme_bw() +
  theme(legend.position = "bottom",
        strip.background = element_rect(fill = "aliceblue"),
        legend.title = element_markdown(),
        text = element_text(size = 11))
     
```

Fit the across-trait $I$ model

```{r}

I_medians <-
  I_index %>% 
  select(Trait, Trait_Sex, I) %>% 
  group_by(Trait, Trait_Sex) %>% 
  summarise_draws("median", "sd", ~quantile(.x, probs = c(0.025, 0.975), na.rm = TRUE)) %>%
  ungroup() %>% 
  rename(I = median) %>% 
  select(-variable) %>% 
  left_join(trait_data %>% 
              distinct(Trait, .keep_all = TRUE) %>% 
              select(Trait, Trait_nice, Life_stage, `Trait guild`, study_ID))


 # fit the model

I_model <- 
  brm(data = I_medians, 
      I | weights(sd) ~ 1 + Trait_Sex + (1|study_ID) + (1|Trait),
      family = gaussian,
      prior = c(prior(normal(0, 0.25), class = Intercept),
                prior(exponential(1), class = sd),
                prior(exponential(5), class = sigma),
                prior(normal(0, 0.25), class = b)), 
      warmup = 4000, iter = 8000,
      seed = 1, cores = 4, chains = 4,
      control = list(adapt_delta = 0.9, max_treedepth = 10),
      file = "fits/I_model")

print(I_model)

```

Get model predictions

```{r}

new_data <- tibble(Trait_Sex = c("Female", "Male"))

I_fitted <-
  fitted(I_model, newdata = new_data, re_formula = NA, summary = F) %>% 
  as.data.frame() %>% 
  rename(Females = V1, Males = V2) %>% 
  as_tibble() %>% 
  pivot_longer(cols = everything(), names_to = "Trait_Sex", values_to = "I")


I_posterior <- 
  as_draws_df(I_model) %>% 
  mutate(Females = b_Intercept,
         Males = b_Intercept + b_Trait_SexMale) %>% 
    select(Females, Males, sigma) 

I_posterior_long <-
bind_cols(
I_posterior,
    tibble(predictive_I_female = rnorm(16000, mean = I_posterior$Females, sd = I_posterior$sigma),
           predictive_I_male = rnorm(16000, mean = I_posterior$Males, sd = I_posterior$sigma))
  ) %>% 
  select(-sigma) %>% 
  pivot_longer(cols = everything(), names_to = "parameter", values_to = "I")

```

Build Figure 4 panel b

```{r}

fig4_panel_b <-
  I_fitted %>% 
  ggplot(aes(x = I, y = Trait_Sex)) +
  stat_halfeye(aes(fill = after_stat(x > 0)),
               .width = c(0.66, 0.95), alpha = 0.9, 
               point_interval = "median_qi", point_fill = "white",
               shape = 21, point_size = 4, stroke = 1.5) + 
  scale_fill_manual(values = c(met.brewer(name = "Paquin", 7)[2], 
                    met.brewer(name = "Tsimshian", 7)[3])) +
  geom_vline(xintercept = 0, linetype = 2, linewidth = 0.75) +
  ylab("Sex traits were measured in") +
  xlab(expression(italic(I)* " across-trait mean (posterior)")) +
  theme_minimal() + 
  theme(panel.background = element_rect(fill='transparent'),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        plot.background = element_rect(fill='transparent', color=NA),
        legend.position = "none",
        text = element_text(size=11))

```

$~$

## Using evidence ratios to detect sexually antagonistic traits

We calculate evidence ratios a for sexually concordant responses to selection by:

1. Using the `p_direction` function from the `bayestestR` package to find the proportion of the posterior distribution that is of the median's sign for each trait in each sex. We use this as the local false sign rate (LFSR).

2. Using the `p_direction` results we found the probability that a trait has positive $R$, $P(pos)$ or negative $R$, $P(neg) = 1 - P(pos)$.

3. Finding $P(concord) = P(pos)_f * P(pos)_m + P(neg)_f * P(neg)_m$

4. Finding $P(antag) = P(pos)_f * P(neg)_m + P(neg)_f * P(pos)_m$

5. Taking the ratio of $P(concord)$ and $P(antag)$


```{r}
pd_function <-function(Trait_name){
  R_all_traits %>% filter(Trait == Trait_name) %>%
    select(Trait, Response_to_selection_female, Response_to_selection_male) %>%
    p_direction(Response_to_selection_female, method = "direct", null = 0) %>%
    as_tibble() %>%
    pivot_wider(names_from = Parameter, values_from = pd) %>%
    mutate(Trait = Trait_name) %>%
    rename(pd_female = Response_to_selection_female,
           pd_male = Response_to_selection_male)
}

trait_list <- unique(R_all_traits$Trait)

pd_data <- map_dfr(trait_list, pd_function)

Trait_medians <-
  R_all_traits %>%
  group_by(Trait) %>%
  summarise(median_female = median(Response_to_selection_female),
            median_male = median(Response_to_selection_male)) %>%
  ungroup()

evidence_ratios <-
  left_join(pd_data, Trait_medians) %>%
  mutate(prob_pos_female = if_else(median_female > 0, pd_female, 1 - pd_female),
         prob_pos_male = if_else(median_male > 0, pd_male, 1 - pd_male)) %>%
  select(Trait, prob_pos_female, prob_pos_male) %>%

    # Calculate the probabilities that beta_i and beta_j have the same/opposite signs
    mutate(p_sex_concord = prob_pos_female  * prob_pos_male +
             (1 - prob_pos_female) * (1 - prob_pos_male),
           p_sex_antag = prob_pos_female * (1 - prob_pos_male) +
             (1 - prob_pos_female) * prob_pos_male) %>%
    # Find the ratios of these two probabilities (i.e. the "evidence ratios")
    mutate(evidence_ratio_concord = p_sex_concord / p_sex_antag) %>%
  left_join(R_all_traits %>% distinct(Trait, Trait_Sex) %>%
              mutate(Trait_Sex = if_else(Trait_Sex == "Female", "Traits measured in females",
                                         "Traits measured in males"))) %>% 
  left_join(clean_meta_data)


```

Build panel c for figure 4 and update panel a

```{r}

fig4_panel_c <-
  evidence_ratios %>%
    ggplot(aes(log2(evidence_ratio_concord))) +
    geom_histogram(data=subset(evidence_ratios, evidence_ratio_concord < 1),
                   bins = 80, fill = met.brewer(name = "Tam", 8)[4]) +
    geom_histogram(data=subset(evidence_ratios, evidence_ratio_concord >= 1),
                   bins = 80, fill = met.brewer(name = "Tsimshian", 7)[3]) +
    coord_cartesian(xlim = c(-8, 8), ylim = c(0, 20)) +
  geom_vline(xintercept = log2(19), linetype = 2) +
  geom_vline(xintercept = log2(1/19), linetype = 2) +
    scale_x_continuous(breaks = c(-8,  -6, -4, -2,   2, 4, 6,  8),
                       labels = c(paste("1/",2 ^ c(8,  6, 4, 2), sep = ""), 2 ^ c(2,4,6,8))) +
    scale_y_continuous(expand = expansion(mult = c(0.01, 0.01))) +

    facet_wrap(~ Trait_Sex) +
    xlab("Evidence ratio (log~2~ scale)") + ylab("Number of traits") +
    theme_bw() +
    theme(#panel.border = element_rect(size = 0.8),
          text = element_text(size = 11),
          axis.text.x = element_text(angle = 45, vjust = 1, hjust=1),
          strip.background = element_rect(fill = "aliceblue"),
          axis.title.x = element_markdown())

plotting_data_er <-
  evidence_ratios %>% select(Trait, Trait_Sex, evidence_ratio_concord) %>% 
  left_join(I_summary, by = c("Trait", "Trait_Sex")) %>% 
  mutate(er_abs = abs(log2(evidence_ratio_concord)))


# add labels to fig3 panel a, using the 'significant' er values

fig4_panel_a <-
  fig4_panel_a +
  geom_label_repel(data = plotting_data_er %>% filter(er_abs > 4.24),  
                   aes(label = Trait_nice), 
                   fill = met.brewer(name = "Paquin", 7)[5],
                   size = 2, alpha = 0.9,
                   min.segment.length = 0, seed = 1,
                   box.padding = 0.5, point.padding = 0.5,
                   max.overlaps = 30) 

```

Fit the across-trait evidence ratio model

```{r}

 # fit the model

er_model <- 
  brm(data = evidence_ratios, 
      log2(evidence_ratio_concord) ~ 1 + Trait_Sex + (1|study_ID),
      family = gaussian,
      prior = c(prior(normal(0, 0.5), class = Intercept),
                prior(exponential(1), class = sd),
                prior(exponential(5), class = sigma),
                prior(normal(0, 0.25), class = b)), 
      warmup = 4000, iter = 8000,
      seed = 1, cores = 4, chains = 4,
      control = list(adapt_delta = 0.9, max_treedepth = 10),
      file = "fits/er_model")

print(er_model)

```

Get model predictions and plot

```{r}

new_data <- tibble(Trait_Sex = c("Trait measured in females", "Trait measured in males"))

er_fitted <-
  fitted(er_model, newdata = new_data, re_formula = NA, summary = F) %>% 
  as.data.frame() %>% 
  rename(Females = V1, Males = V2) %>% 
  as_tibble() %>% 
  pivot_longer(cols = everything(), names_to = "Trait_Sex", values_to = "evidence_ratio_mean") %>% 
  mutate(evidence_ratio_mean = exp(evidence_ratio_mean))

```

```{r}
fig4_panel_d <-
  er_fitted %>% 
  ggplot(aes(x = evidence_ratio_mean, y = Trait_Sex)) +
  stat_halfeye(aes(fill = after_stat(x > 1)),
               .width = c(0.66, 0.95), alpha = 0.9, 
               point_interval = "median_qi", point_fill = "white",
               shape = 21, point_size = 4, stroke = 1.5) + 
  scale_fill_manual(values = c(met.brewer(name = "Paquin", 7)[2], 
                    met.brewer(name = "Tsimshian", 7)[3])) +
  geom_vline(xintercept = 1, linetype = 2, linewidth = 0.75) +
  ylab("Sex traits were measured in") +
  xlab("Evidence ratio across-trait\nmean (posterior)") +
  #scale_x_continuous(limits = c(-1, 1), breaks = c(-1,  -0.2876821, 0, 0.4054651, 0.6931472),
    #                   labels = c("1/2", "3/4", 1, "1.5", "2")) +
  theme_minimal() + 
  theme(panel.background = element_rect(fill='transparent'),
        panel.grid.major.y = element_blank(),
        panel.grid.minor.y = element_blank(),
        plot.background = element_rect(fill='transparent', color=NA),
        legend.position = "none",
        text = element_text(size=11))

```

## Figure 4

```{r, fig.width=14, fig.height=10}
(fig4_panel_a | plot_spacer() | fig4_panel_b) / 
  (fig4_panel_c | plot_spacer() | fig4_panel_d) &
  plot_layout(widths = c(3, -0.5, 1)) &  
  plot_annotation(tag_levels = 'a')

```

**Figure 4**. **a** Concordance and conflict in the _Drosophila melanogaster_ phenome. **a** shows traits coloured by Innocenti and Morrow's I index. Extreme positive values indicate a trait is predicted to have a sexually concordant response to selection, while negative values indicate a trait is expected to have a sexually antagonistic response to selection. Traits with evidence ratios > 19 are labelled. **b** the mean _I_ value estimated across all traits, split by the sex traits were measured in. **c** evidence ratios for sexually concordant responses to selection. Dashed lines indicate an evidence ratio of 19, which is equivalent to a frequentist _p_-value = 0.05. **d** the mean evidence ratio estimated across all traits, split by the sex traits were measured in. Points indicate the mean point estimate, with associated 67 and 95% credible intervals.
